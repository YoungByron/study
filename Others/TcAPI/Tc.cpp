


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 头文件
#include <Windows.h>
#include "Shlwapi.h"
#pragma comment( lib, "Shlwapi.lib")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "cstack.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 宏定义
#define EXTERNC extern "C"
#define NAKED __declspec(naked)
#define EXPORT __declspec(dllexport)

#define ALCPP EXPORT NAKED
#define ALSTD EXTERNC EXPORT NAKED void __stdcall
#define ALCFAST EXTERNC EXPORT NAKED void __fastcall
#define ALCDECL EXTERNC NAKED void __cdecl
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define HOOK_LEN 0xC
// 保存原始指令
BYTE Ori_Code[HOOK_LEN] = {0x00};
BYTE HookCode[HOOK_LEN] = { 0x48, 0xB8, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x50, 0xC3 };

void HookApi();
void UnHookApi();

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// AheadLib 命名空间
namespace AheadLib
{
	HMODULE m_hModule = NULL;		// 原始模块句柄
	DWORD m_dwReturn[23] = {0};		// 原始函数返回地址


	// 加载原始模块
	inline BOOL WINAPI Load()
	{
		TCHAR tzPath[MAX_PATH];
		TCHAR tzTemp[MAX_PATH * 2];

		lstrcpy(tzPath, TEXT("TcOrg"));
		m_hModule = LoadLibrary(tzPath);
		if (m_hModule == NULL)
		{
			wsprintf(tzTemp, TEXT("无法加载 %s，程序无法正常运行。"), tzPath);
			MessageBox(NULL, tzTemp, TEXT("AheadLib"), MB_ICONSTOP);
		}

		return (m_hModule != NULL);	
	}
		
	// 释放原始模块
	inline VOID WINAPI Free()
	{
		if (m_hModule)
		{
			FreeLibrary(m_hModule);
		}
	}

	// 获取原始函数地址
	FARPROC WINAPI GetAddress(PCSTR pszProcName)
	{
		//myStack.push(pszProcName);

		string dbgStr = "Tc::Begin--> ";

		ostringstream os;
		os<<dbgStr<<myStack.size()<<" "<<pszProcName;
		::OutputDebugString(os.str().c_str());

		FARPROC fpAddress;
		CHAR szProcName[64];
		TCHAR tzTemp[MAX_PATH];

		fpAddress = GetProcAddress(m_hModule, pszProcName);
		if (fpAddress == NULL)
		{
			if (HIWORD(pszProcName) == 0)
			{
				wsprintfA(szProcName, "%d", pszProcName);
				pszProcName = szProcName;
			}

			wsprintf(tzTemp, TEXT("无法找到函数 %hs，程序无法正常运行。"), pszProcName);
			MessageBox(NULL, tzTemp, TEXT("AheadLib"), MB_ICONSTOP);
			ExitProcess(-2);
		}

		return fpAddress;
	}

	 inline VOID WINAPI  PopDbgStrFuncEnd(PCSTR pszProcName)
	{
		// 保存返回地址
		__asm PUSH EDI;
		__asm PUSH ESI;
		__asm PUSH EBX;
		__asm PUSH EAX;
		__asm PUSH ECX;
		__asm PUSH EDX;

		//myStack.push("TcEnd");
// 		string dbgStr = "Tc::E n d--> ";
// 		ostringstream os;
// 		if (myStack.size()>0)
// 		{
// 			os<<dbgStr<<myStack.pop()<<" "<<myStack.size();
// 		}
// 		else
// 		{
// 			os<<dbgStr<<" "<<myStack.size();
// 		}
		::OutputDebugString(pszProcName);
		__asm POP EDX;
		__asm POP ECX;
		__asm POP EAX;
		__asm POP EBX;
		__asm POP ESI;
		__asm POP EDI;
		
	}

}
using namespace AheadLib;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//先声明Hook的API -- 赋值改成你要Hook的API；注意参数、返回值类型
static HMODULE (WINAPI * kernel_BeHooked_Api)(LPCSTR lpFileName) = LoadLibraryA;

//定义自己的API，参数和返回类型与上面声明的保持一致 -- 原API将被转到这里执行
HMODULE WINAPI My_Hook_Api(LPCSTR lpFileName)
{
	///////////////////////////////////////////////////////////////////
	//  下面是原API执行前想要做的事
	///////////////////////////////////////////////////////////////////
	DWORD PatchAddr    = 0;              //改为实际要补丁的地址
	BYTE  oldData[2]   = {0x74,0x1f};    //改为实际的带补丁代码
	BYTE  patchData[2] = {0x74,0x00};    //改为补丁数据
	BYTE  bufRead[2]   = {0};            //改为实际要读取进程的字节数

	DWORD dwOldProtect;
	DWORD bytesReadWritten;
	///////////////////////////////////////////////////////////////////


	///////////////////////////////////////////////////////////////////
	//  执行原API
	///////////////////////////////////////////////////////////////////
	UnHookApi();
	//  请注意修改参数和返回值类型
	HMODULE hRet = kernel_BeHooked_Api(lpFileName); 
	HookApi();
	///////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////
	//  下面是原API执行后想要做的事
	///////////////////////////////////////////////////////////////////
	PatchAddr = (DWORD)hRet + 0x103C; //改为你要补丁的目标地址！
	HANDLE hProcess = GetCurrentProcess();

	VirtualProtect((LPVOID)PatchAddr, sizeof(DWORD), PAGE_READWRITE, &dwOldProtect);
	ReadProcessMemory(hProcess, (LPVOID)PatchAddr, (LPVOID)bufRead, 2, &bytesReadWritten);
	if (memcmp(bufRead, oldData, 2) == 0)
	{
		OutputDebugString(TEXT("[PYG] Found the target!"));
		WriteProcessMemory(hProcess, (LPVOID)PatchAddr, &patchData, 2, &bytesReadWritten);
		OutputDebugString(TEXT("[PYG] Patch successfully!"));
	}
	VirtualProtect((LPVOID)PatchAddr, sizeof(DWORD), dwOldProtect, &dwOldProtect);
	///////////////////////////////////////////////////////////////////

	//注意返回值类型
	return hRet;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void HookApi()
{
	DWORD dwOldProtect;
	//获取内存权限
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	//保存原代码数据
	memcpy(Ori_Code, kernel_BeHooked_Api, HOOK_LEN);
	//填入自己函数的地址
	*(PDWORD)(HookCode+2) = (DWORD)&My_Hook_Api;
	 //写入进程内存
	memcpy(kernel_BeHooked_Api, HookCode, HOOK_LEN);
	//恢复内存权限
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, dwOldProtect, &dwOldProtect);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UnHookApi()
{
	DWORD dwOldProtect;
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, PAGE_EXECUTE_READWRITE, &dwOldProtect);
	memcpy(kernel_BeHooked_Api, Ori_Code, HOOK_LEN);
	::VirtualProtect(kernel_BeHooked_Api, HOOK_LEN, dwOldProtect, &dwOldProtect);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 入口函数
BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hModule);

		if(Load())
		{
			TCHAR szAppName[MAX_PATH]  = TEXT("TdxW.exe");	//请改为相应的Dll宿主文件名
			TCHAR szFullPath[MAX_PATH] = {0};
			int nLength = 0;
			nLength = GetModuleFileName(NULL, szFullPath, MAX_PATH);
			PathStripPath(szFullPath);
			if (StrCmpI(szAppName, szFullPath) == 0)
			{
				OutputDebugString(TEXT("[PYG] Dll Loaded successfully!"));
				HookApi();
			}
		}
		else
		{
			return FALSE;
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		Free();
	}

	return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
#pragma comment(linker, "/EXPORT:TC_AfterStatusChange=_AheadLib_TC_AfterStatusChange,@1")
#pragma comment(linker, "/EXPORT:TC_ArrangeWnd=_AheadLib_TC_ArrangeWnd,@2")
#pragma comment(linker, "/EXPORT:TC_BeforeHideWT=_AheadLib_TC_BeforeHideWT,@3")
#pragma comment(linker, "/EXPORT:TC_CallExtrenURL=_AheadLib_TC_CallExtrenURL,@4")
#pragma comment(linker, "/EXPORT:TC_CreateAll=_AheadLib_TC_CreateAll,@5")
#pragma comment(linker, "/EXPORT:TC_DoGridJy=_AheadLib_TC_DoGridJy,@6")
#pragma comment(linker, "/EXPORT:TC_DoLevinGN=_AheadLib_TC_DoLevinGN,@7")
#pragma comment(linker, "/EXPORT:TC_DoLevinJy=_AheadLib_TC_DoLevinJy,@8")
#pragma comment(linker, "/EXPORT:TC_GetClientInfo=_AheadLib_TC_GetClientInfo,@9")
#pragma comment(linker, "/EXPORT:TC_GetDlg=_AheadLib_TC_GetDlg,@10")
#pragma comment(linker, "/EXPORT:TC_GetJyStatus=_AheadLib_TC_GetJyStatus,@11")
#pragma comment(linker, "/EXPORT:TC_GetL2Info=_AheadLib_TC_GetL2Info,@12")
#pragma comment(linker, "/EXPORT:TC_GetLoginRet=_AheadLib_TC_GetLoginRet,@13")
#pragma comment(linker, "/EXPORT:TC_GetRightInfo=_AheadLib_TC_GetRightInfo,@14")
#pragma comment(linker, "/EXPORT:TC_GetTCInfo=_AheadLib_TC_GetTCInfo,@15")
#pragma comment(linker, "/EXPORT:TC_GetVersion=_AheadLib_TC_GetVersion,@16")
#pragma comment(linker, "/EXPORT:TC_Init_Environ=_AheadLib_TC_Init_Environ,@17")
#pragma comment(linker, "/EXPORT:TC_Login=_AheadLib_TC_Login,@18")
#pragma comment(linker, "/EXPORT:TC_PreTransMsg=_AheadLib_TC_PreTransMsg,@19")
#pragma comment(linker, "/EXPORT:TC_RegisterCallBack=_AheadLib_TC_RegisterCallBack,@20")
#pragma comment(linker, "/EXPORT:TC_SetFeedBackMsg=_AheadLib_TC_SetFeedBackMsg,@21")
#pragma comment(linker, "/EXPORT:TC_SetVersionInfo=_AheadLib_TC_SetVersionInfo,@22")
#pragma comment(linker, "/EXPORT:TC_Uninit=_AheadLib_TC_Uninit,@23")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_AfterStatusChange(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[0 * TYPE long];

	// 调用原始函数
	GetAddress("TC_AfterStatusChange")();

	PopDbgStrFuncEnd("TC_AfterStatusChange");
	// 转跳到返回地址
	__asm JMP m_dwReturn[0 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_ArrangeWnd(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[1 * TYPE long];

	// 调用原始函数
	GetAddress("TC_ArrangeWnd")();

	PopDbgStrFuncEnd("TC_ArrangeWnd");
	// 转跳到返回地址
	__asm JMP m_dwReturn[1 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_BeforeHideWT(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[2 * TYPE long];

	// 调用原始函数
	GetAddress("TC_BeforeHideWT")();

	PopDbgStrFuncEnd("TC_BeforeHideWT");
	// 转跳到返回地址
	__asm JMP m_dwReturn[2 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_CallExtrenURL(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[3 * TYPE long];

	// 调用原始函数
	GetAddress("TC_CallExtrenURL")();

	PopDbgStrFuncEnd("TC_CallExtrenURL");
	// 转跳到返回地址
	__asm JMP m_dwReturn[3 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_CreateAll(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[4 * TYPE long];

	// 调用原始函数
	GetAddress("TC_CreateAll")();

	PopDbgStrFuncEnd("TC_CreateAll");
	// 转跳到返回地址
	__asm JMP m_dwReturn[4 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_DoGridJy(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[5 * TYPE long];

	// 调用原始函数
	GetAddress("TC_DoGridJy")();

	PopDbgStrFuncEnd("TC_DoGridJy");
	// 转跳到返回地址
	__asm JMP m_dwReturn[5 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_DoLevinGN(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[6 * TYPE long];

	// 调用原始函数
	GetAddress("TC_DoLevinGN")();

	PopDbgStrFuncEnd("TC_DoLevinGN");
	// 转跳到返回地址
	__asm JMP m_dwReturn[6 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_DoLevinJy(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[7 * TYPE long];

	// 调用原始函数
	GetAddress("TC_DoLevinJy")();

	PopDbgStrFuncEnd("TC_DoLevinJy");
	// 转跳到返回地址
	__asm JMP m_dwReturn[7 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetClientInfo(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[8 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetClientInfo")();

	PopDbgStrFuncEnd("TC_GetClientInfo");
	// 转跳到返回地址
	__asm JMP m_dwReturn[8 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetDlg(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[9 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetDlg")();

	PopDbgStrFuncEnd("TC_GetDlg");
	// 转跳到返回地址
	__asm JMP m_dwReturn[9 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetJyStatus(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[10 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetJyStatus")();

	PopDbgStrFuncEnd("TC_GetJyStatus");
	// 转跳到返回地址
	__asm JMP m_dwReturn[10 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetL2Info(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[11 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetL2Info")();

	PopDbgStrFuncEnd("TC_GetL2Info");
	// 转跳到返回地址
	__asm JMP m_dwReturn[11 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetLoginRet(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[12 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetLoginRet")();

	PopDbgStrFuncEnd("TC_GetLoginRet");
	// 转跳到返回地址
	__asm JMP m_dwReturn[12 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetRightInfo(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[13 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetRightInfo")();

	PopDbgStrFuncEnd("TC_GetRightInfo");
	// 转跳到返回地址
	__asm JMP m_dwReturn[13 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetTCInfo(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[14 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetTCInfo")();

	PopDbgStrFuncEnd("TC_GetTCInfo");
	// 转跳到返回地址
	__asm JMP m_dwReturn[14 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_GetVersion(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[15 * TYPE long];

	// 调用原始函数
	GetAddress("TC_GetVersion")();

	PopDbgStrFuncEnd("TC_GetVersion");
	// 转跳到返回地址
	__asm JMP m_dwReturn[15 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_Init_Environ(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[16 * TYPE long];

	// 调用原始函数
	GetAddress("TC_Init_Environ")();

	PopDbgStrFuncEnd("TC_Init_Environ");
	// 转跳到返回地址
	__asm JMP m_dwReturn[16 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_Login(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[17 * TYPE long];

	// 调用原始函数
	GetAddress("TC_Login")();

	PopDbgStrFuncEnd("TC_Login");
	// 转跳到返回地址
	__asm JMP m_dwReturn[17 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_PreTransMsg(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[18 * TYPE long];

	// 调用原始函数
	GetAddress("TC_PreTransMsg")();

	PopDbgStrFuncEnd("TC_PreTransMsg");
	// 转跳到返回地址
	__asm JMP m_dwReturn[18 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_RegisterCallBack(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[19 * TYPE long];

	// 调用原始函数
	GetAddress("TC_RegisterCallBack")();

	PopDbgStrFuncEnd("TC_RegisterCallBack");
	// 转跳到返回地址
	__asm JMP m_dwReturn[19 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_SetFeedBackMsg(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[20 * TYPE long];

	// 调用原始函数
	GetAddress("TC_SetFeedBackMsg")();

	PopDbgStrFuncEnd("TC_SetFeedBackMsg");
	// 转跳到返回地址
	__asm JMP m_dwReturn[20 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_SetVersionInfo(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[21 * TYPE long];

	// 调用原始函数
	GetAddress("TC_SetVersionInfo")();

	PopDbgStrFuncEnd("TC_SetVersionInfo");
	// 转跳到返回地址
	__asm JMP m_dwReturn[21 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 导出函数
ALCDECL AheadLib_TC_Uninit(void)
{
	// 保存返回地址
	__asm POP m_dwReturn[22 * TYPE long];

	// 调用原始函数
	GetAddress("TC_Uninit")();

	PopDbgStrFuncEnd("TC_Uninit");
	// 转跳到返回地址
	__asm JMP m_dwReturn[22 * TYPE long];
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
